Research Report (Simulation Techniques for Animation)
Title: Exploring GPU acceleration for integration schemes in Mass-spring systems
Name: Joe Withers
Course: CVA                   Student No: i7463769
Introduction (250-500 words):
For this project I will be exploring the differences between different integration schemes within a simple Mass-Spring system demo. For each integration scheme I am to evaluate the feasibility of offloading the computation onto the GPU, either through the use of CUDA or OpenGL compute shaders.
Methods (400 – 800 words):
I will be using the following methods:
Mass Spring system
Within my mass spring system I will choose from a range of Explicit and Implicit integration schemes:
Runge-Kutta (RK4)
Runge-Kutta Midpoint (RK2)
Euler Method
I will be using the following tools:
C++
OpenGL (NGL)
Qt5
CUDA, or OpenGL compute shaders
I plan to create a simple Mass-Spring system demo that includes the following features:
A Jelly cube that can be interacted with, either through collisions with other objects, or user application of external forces.
User control of various parameters, such as spring constant, damping, timestep etc.
User selection of the different integration schemes available
Perhaps a way to view the accumulated error?
For my first attempt at GPU implementation I decided to store each the attributes for each mass and each spring in openGL textures, and to use Image Load/Store commands for bindless textures for accessing and manipulating data. I implemented the following attributes as 1D textures:
Mass positions (Vec3, RGBA32F, size = number of masses)
Spring ‘state’ position attribute (Vec3, RGBA32F, size = number of springs)
Spring ‘state’ velocity attribute (Vec3, RGBA32F, size = number of springs)
Spring resting length attribute (Float, R32F, size = number of springs)
The spring start and end index attributes serve as a ‘pointer’ to an index in the mass positions texture which they manipulate.
Spring start index attribute (Unsigned Int, R16UI, size = number of springs)
Spring end index attribute (Unsigned Int, R16UI, size = number of springs)
To initialise these textures, I first dispatch a compute shader with workgroups equal to the dimensions of my ‘JelloCube’ object. This sets the initial position for the masses in the mass positions texture, whilst also counting how many springs need to be created using an atomic counter. I then read the contents of atomic counter and create the textures necessary for spring attributes, whose length is equal to the number of springs counted by the atomic counter. The atomic counter is then reset, and the compute shader is then dispatched for a second time, however this time it calls a subroutine which stores the spring attributes into each corresponding texture.
Whilst this approach works, I am maintaining six textures at once, and have found that once the number of masses is increased past 1000, the number of springs needed to be stored exceeds the number of texels I can specify with glTexImage1D (at least on my system). I have therefore decided to switch to using Shader Storage Buffer Objects, as their size is only limited by the amount of memory on the GPU, and they are much easier to maintain and manipulate compared to textures.
I have since changed the system to use Shader Storage Buffer Objects, which I have found to be much faster, allowing up to 1.5 million springs to be calculated at once with interactive framerates.
Critical analysis (150 – 300 words):
Analysis and comparison of the main methods listed, including personal reflection and insight.
Reference List:
Mass spring systems on the GPU ( use newtons second law)
Disclaimer: We have endeavoured to make the information provided in this assignment template is correct at time of publication. However, there may be typos and mistakes so it will be your own responsibility to check. Please do not hesitate to contact jchang@bournemouth.ac.uk if you have any queries.

